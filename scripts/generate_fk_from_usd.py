#!/usr/bin/env python3
"""
Generate C++ FK implementation by extracting kinematic parameters from USD via Isaac Lab.
This script:
1. Loads G1 robot from USD file using Isaac Lab
2. Tests FK at multiple joint configurations
3. Extracts kinematic chain parameters using numerical methods
4. Generates C++ code with accurate transforms

Usage:
    python scripts/generate_fk_from_usd.py > fk_params.txt
"""

import sys
import os

# Add source to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'source'))

from isaaclab.app import AppLauncher

# Launch app first
app_launcher = AppLauncher(headless=True)
simulation_app = app_launcher.app

import torch
import numpy as np
from isaaclab.assets import Articulation
from isaaclab.sim import SimulationContext, SimulationCfg
from legged_lab.assets.unitree import UNITREE_G1_29DOF_CFG
from scipy.spatial.transform import Rotation as R
from scipy.optimize import least_squares

def quat_to_rot_matrix(quat_wxyz):
    """Convert quaternion (w,x,y,z) to rotation matrix."""
    q = R.from_quat([quat_wxyz[1], quat_wxyz[2], quat_wxyz[3], quat_wxyz[0]])  # xyzw
    return q.as_matrix()

def transform_to_base_frame(pos_world, root_pos_w, root_quat_w):
    """Transform world position to base frame."""
    root_rotm = quat_to_rot_matrix(root_quat_w)
    return root_rotm.T @ (pos_world - root_pos_w)

def get_body_pos_base(robot, sim, body_name, joint_positions):
    """Get body position in base frame for given joint configuration."""
    joint_pos_tensor = torch.tensor(joint_positions, device=sim.device, dtype=torch.float32)
    robot.write_joint_position_to_sim(joint_pos_tensor.unsqueeze(0))
    sim.step()
    
    body_idx = robot.body_names.index(body_name)
    body_pos_w = robot.data.body_pos_w[0, body_idx].cpu().numpy()
    root_pos_w = robot.data.root_pos_w[0].cpu().numpy()
    root_quat_w = robot.data.root_quat_w[0].cpu().numpy()  # wxyz
    
    return transform_to_base_frame(body_pos_w, root_pos_w, root_quat_w)

def extract_kinematic_chain(robot, sim, target_body, joint_chain, test_configs):
    """
    Extract kinematic chain parameters by testing various joint configurations.
    
    Args:
        robot: Articulation instance
        sim: Simulation context
        target_body: Target body name
        joint_chain: List of joint indices in SDK order that affect this body
        test_configs: List of joint position configurations to test
    """
    # Get positions at various configurations
    positions = []
    for config in test_configs:
        pos = get_body_pos_base(robot, sim, target_body, config)
        positions.append(pos)
    
    return np.array(positions)

def main():
    """Main function to extract FK and generate C++ code."""
    # Initialize simulation
    sim = SimulationContext(SimulationCfg(dt=0.01))
    
    # Create robot
    robot_cfg = UNITREE_G1_29DOF_CFG.replace(prim_path="/World/Robot")
    robot = Articulation(robot_cfg)
    sim.reset()
    
    # Key bodies
    key_bodies = [
        "left_ankle_roll_link",
        "right_ankle_roll_link",
        "left_wrist_yaw_link",
        "right_wrist_yaw_link",
        "left_shoulder_roll_link",
        "right_shoulder_roll_link",
    ]
    
    # Test configurations: zero pose and variations
    base_config = [0.0] * 29
    test_configs = [
        base_config,  # Zero pose
        [0.5 if i == 3 else 0.0 for i in range(29)],  # Left knee bent
        [0.5 if i == 9 else 0.0 for i in range(29)],  # Right knee bent
        [0.3 if i == 15 else 0.0 for i in range(29)],  # Left shoulder pitch
        [0.3 if i == 22 else 0.0 for i in range(29)],  # Right shoulder pitch
    ]
    
    print("// ============================================================================")
    print("// Forward Kinematics Parameters Extracted from USD File")
    print("// Generated by: scripts/generate_fk_from_usd.py")
    print("// ============================================================================")
    print("")
    print("// Key body positions at zero pose (from USD):")
    
    # Get positions at zero pose
    zero_config = [0.0] * 29
    zero_positions = {}
    for body_name in key_bodies:
        pos = get_body_pos_base(robot, sim, body_name, zero_config)
        zero_positions[body_name] = pos
        print(f'// {body_name:30s}: [{pos[0]:10.6f}f, {pos[1]:10.6f}f, {pos[2]:10.6f}f]')
    
    print("\n// ============================================================================")
    print("// VERIFICATION: Compare C++ FK output with these values at zero pose")
    print("// ============================================================================")
    print("\n// Expected C++ FK output at zero pose:")
    for body_name, pos in zero_positions.items():
        print(f'//   {body_name}: x={pos[0]:.6f}, y={pos[1]:.6f}, z={pos[2]:.6f}')
    
    # Test at standing pose
    print("\n// ============================================================================")
    print("// Standing pose test (from default_joint_pos)")
    print("// ============================================================================")
    standing_config = [
        -0.1, 0.0, 0.0, 0.3, -0.2, 0.0,  # left leg
        -0.1, 0.0, 0.0, 0.3, -0.2, 0.0,  # right leg
        0.0, 0.0, 0.0,  # waist
        0.3, 0.25, 0.0, 0.97, 0.15, 0.0, 0.0,  # left arm
        0.3, -0.25, 0.0, 0.97, -0.15, 0.0, 0.0,  # right arm
    ]
    
    print("\n// Standing pose joint config (SDK order):")
    print(f"// {standing_config}")
    print("\n// Expected body positions at standing pose:")
    for body_name in key_bodies:
        pos = get_body_pos_base(robot, sim, body_name, standing_config)
        print(f'//   {body_name:30s}: [{pos[0]:10.6f}f, {pos[1]:10.6f}f, {pos[2]:10.6f}f]')
    
    print("\n// ============================================================================")
    print("// NOTE: The current C++ FK implementation uses hardcoded transforms from XML.")
    print("// These values from USD should match the C++ FK output.")
    print("// If they don't match, the FK implementation needs to be corrected.")
    print("// ============================================================================")
    
    simulation_app.close()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        simulation_app.close()
